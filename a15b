# print file size and name

ls -lR $* | awk '

BEGIN {
	printf "%-20s %-20s %-20s\n", "BYTES", "#FILES", "DIRECTORY"
	counter4dir=-1 # Not necessary but setting value so array starts at 0
	couter4output=-1
	numberFilesEachDirectory=0
	bytesSum=0
	
	# Declare aray with units
	split("0 1024 1048576 1073741824 1099511627800 1125899906842624 1152921504606846976", arrayUnits )
	
	# Declare aray with units labels
	split("bytes KiB MiB GiB TiB PiB EiB", arrayLabels )
	
	unitsLength = countArrayElements(arrayUnits)

}

{
	if ( $1 ~ /^\..*:$/ ) {
		counter4dir++
		arrayDirectoryNames[counter4dir]= $1
		# Resetting the value of bytesSum for each directory
		bytesSum = 0
		numberFilesEachDirectory=0
	}
	
	if ( $1 ~ /^-/ ) {
		bytesSum += $5
		arrayFileSizes[counter4dir]= bytesSum
		numberFilesEachDirectory++
		arrayNumFiles[counter4dir]= numberFilesEachDirectory
	}
}


# This fucntion counts the number of element in an array
function countArrayElements(myArray){
	for ( e in myArray) {
		c++
	}
	return c
}
	

# Function convert bytes to other formats

function convertBytes (convertMe, arrayUnitsII, unitsLengthII, arrayLabelsII ) {
		
	for ( counter = 1; counter < unitsLengthII; counter++ ) {
		
		if ( convertMe >= arrayUnitsII[counter] && convertMe < arrayUnitsII[counter+1] ){

			# Ternary operator to handle the exception for bytes between 0 -1024
			# The code would give back a value to low when divided by zero
			(convertMe < 1024) ? convertedVal = convertMe : convertedVal = sprintf( "%.3f", convertMe/arrayUnitsII[counter] )
			
			return convertedVal " " arrayLabelsII[counter]
		}
	}
		
}


END {

	for ( i in arrayDirectoryNames ){
		couter4output++
		printf "%-20s %-20d %-20s\n",  convertBytes( arrayFileSizes[couter4output], arrayUnits, unitsLength, arrayLabels), arrayNumFiles[couter4output], arrayDirectoryNames[couter4output]
	}
	
}
'